/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { IncomingMessage, IncomingHttpHeaders } from 'http';
import { Readable } from 'stream';
import { RetryOptions } from './retry';
import * as $tea from '@alicloud/tea-typescript';
type TeaDict = {
    [key: string]: string;
};
type TeaObject = {
    [key: string]: any;
};
export declare class BytesReadable extends Readable {
    value: Buffer;
    constructor(value: string | Buffer);
    _read(): void;
}
export declare class Request {
    protocol: string;
    port: number;
    method: string;
    pathname: string;
    query: TeaDict;
    headers: TeaDict;
    body: Readable;
    constructor();
}
export declare class Response {
    statusCode: number;
    statusMessage: string;
    headers: TeaDict;
    body: IncomingMessage;
    constructor(httpResponse: IncomingMessage);
    convertHeaders(headers: IncomingHttpHeaders): TeaDict;
    readBytes(): Promise<Buffer>;
}
export declare function doAction(request: Request, runtime?: TeaObject): Promise<Response>;
export declare function toMap(value?: any, withoutStream?: boolean): any;
export declare class Model extends $tea.Model {
    [key: string]: any;
    constructor(map?: TeaObject);
    validate(): void;
    copyWithoutStream<T extends Model>(): T;
    toMap(withoutStream?: boolean): TeaObject;
    static validateRequired(key: string, value: any): void;
    static validateMaxLength(key: string, value: any, max: number): void;
    static validateMinLength(key: string, value: any, min: number): void;
    static validateMaximum(key: string, value: number | undefined, max: number): void;
    static validateMinimum(key: string, value: number | undefined, min: number): void;
    static validatePattern(key: string, value: any, val: string): void;
    static validateArray(data?: any[]): void;
    static validateMap(data?: {
        [key: string]: any;
    }): void;
}
export declare class FileField extends Model {
    filename: string;
    contentType: string;
    content: Readable;
    static names(): {
        [key: string]: string;
    };
    static types(): {
        [key: string]: any;
    };
    constructor(map?: {
        [key: string]: any;
    });
}
export declare class ExtendsParameters extends $tea.Model {
    headers?: {
        [key: string]: string;
    };
    queries?: {
        [key: string]: string;
    };
    static names(): {
        [key: string]: string;
    };
    static types(): {
        [key: string]: any;
    };
    constructor(map?: {
        [key: string]: any;
    });
}
export declare class RuntimeOptions extends $tea.Model {
    retryOptions?: RetryOptions;
    autoretry?: boolean;
    ignoreSSL?: boolean;
    key?: string;
    cert?: string;
    ca?: string;
    maxAttempts?: number;
    backoffPolicy?: string;
    backoffPeriod?: number;
    readTimeout?: number;
    connectTimeout?: number;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string;
    maxIdleConns?: number;
    keepAlive?: boolean;
    extendsParameters?: ExtendsParameters;
    static names(): {
        [key: string]: string;
    };
    static types(): {
        [key: string]: any;
    };
    constructor(map?: {
        [key: string]: any;
    });
}
export declare function cast<T>(obj: any, t: T): T;
export declare function allowRetry(retry: TeaObject, retryTimes: number, startTime: number): boolean;
export declare function getBackoffTime(backoff: TeaObject, retryTimes: number): number;
export declare function isRetryable(err: Error): boolean;
export {};
